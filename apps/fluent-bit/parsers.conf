[PARSER]
    Name        cri
    Format      regex
    Regex       ^(?<time>[^ ]+) (?<stream>stdout|stderr) (?<logtag>[^ ]*) (?<log>.*)$
    Time_Key    time
    Time_Format %Y-%m-%dT%H:%M:%S.%L%z

[PARSER]
    Name        docker
    Format      json
    Time_Key    time
    Time_Format %Y-%m-%dT%H:%M:%S.%L
    Time_Keep   On

[PARSER]
    Name        cali_logic_parser
    Format      regex
    # Regex 내 timestamp 그룹명을 유지하여 Time_Key와 매칭합니다.
    Regex       ^\[(?<level>[A-Z]+)\]\s+(?<timestamp>\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\.\d{3})\s+(?<service>[^/]+)/(?<version>[^\s]+)\s+\[(?<trace_id>[^\]]+)\]:\s+(?<message>.*)$
    Time_Key    timestamp
    Time_Format %Y-%m-%d %H:%M:%S.%L
    Time_Keep   On

[MULTILINE_PARSER]
    Name          multiline_start
    Type          regex
    Flush_timeout 1000
    # [INFO], [ERROR] 등으로 시작하는 줄을 새로운 메시지의 시작으로 인식
    Rule      "start_state"   "/^\[(INFO|ERROR|WARN)\]/"   "cont"
    # 다음 로그 시작점이 나오기 전까지의 모든 줄(Stack Trace 등)을 이전 로그에 포함
    Rule      "cont"          "/^(?!\[(INFO|ERROR|WARN)\])/"   "cont"